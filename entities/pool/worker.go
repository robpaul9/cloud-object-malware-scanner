package pool

import (
	"sync"

	"github.com/robpaul9/go-tools/pkg/log"
)

type Job struct {
	ID       string
	Process  func() error
	Name     string
	Metadata map[string]string
}

type Worker struct {
	JobQueue chan Job
	quit     chan bool
	ID       string
	Logger   log.Logger
	wg       *sync.WaitGroup
}

func newWorker(jobQueue chan Job, logger log.Logger, wg *sync.WaitGroup) Worker {
	return Worker{
		JobQueue: jobQueue,
		quit:     make(chan bool, 1),
		Logger:   logger,
		wg:       wg,
	}
}

func (w *Worker) Start() {
	for {
		select {
		case job := <-w.JobQueue:
			w.Logger.InfoWithFields("job processing",
				log.Fields{
					"job_id":        job.ID,
					"worker_number": w.ID,
					"job_name":      job.Name,
					"job_status":    "pending",
				})
			err := job.Process()
			if err != nil {
				w.Logger.ErrorWithFields(err,
					log.Fields{
						"job_id":        job.ID,
						"worker_number": w.ID,
						"job_name":      job.Name,
						"job_status":    "failed",
					})
			} else {
				w.Logger.InfoWithFields("job finished",
					log.Fields{
						"job_id":        job.ID,
						"worker_number": w.ID,
						"job_name":      job.Name,
						"job_status":    "finished",
					})
			}

		case <-w.quit:
			w.wg.Done()
			return
		}
	}
}

func (w Worker) Stop() {
	w.quit <- true
}
