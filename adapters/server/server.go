package server

import (
	"fmt"
	"net/http"

	"github.com/robpaul9/cloud-object-malware-scanner/usecases/middleware"
	"github.com/robpaul9/go-tools/pkg/log"
	"github.com/robpaul9/go-tools/pkg/trace"
	httptrace "github.com/robpaul9/go-tools/pkg/trace/http"
)

type Config struct {
	DDAgentHost       string
	DDAgentPort       string
	ServiceName       string
	ServicePort       string
	Logger            log.Logger
	MiddlewareService middleware.Service
}

type Server struct {
	*Config
	traceClient trace.Client
}

func New(config *Config) *Server {
	return &Server{
		Config: config,
		traceClient: trace.New(
			config.DDAgentHost, config.DDAgentPort, config.ServiceName),
	}
}

func (s *Server) Start() {
	if s.DDAgentHost != "" {
		s.traceClient = trace.New(s.DDAgentHost, s.DDAgentPort, s.ServiceName)
		s.traceClient.Start()
	}

	router := httptrace.NewTracedServeMux(s.ServiceName)

	router.Handle("/v1/health",
		s.MiddlewareService.GetRequest(
			s.MiddlewareService.RequireHeaders(
				s.MiddlewareService.Auth(
					http.HandlerFunc(s.Health)))))

	address := fmt.Sprintf("0.0.0.0:%s", s.ServicePort)
	s.Logger.Infof("application is serving on %s", address)

	s.Logger.Fatal(http.ListenAndServe(address, router))

}
func (s *Server) Health(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
}

func (s *Server) Stop() {
	if s.traceClient != nil {
		s.traceClient.Stop()
	}
}
