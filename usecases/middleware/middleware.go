package middleware

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/robpaul9/go-tools/pkg/log"

	dbclient "github.com/robpaul9/cloud-object-malware-scanner/db/client"
	"github.com/robpaul9/cloud-object-malware-scanner/models"
)

type Config struct {
	Logger     log.Logger
	ClientRepo dbclient.IClientRepo
}

type Service struct {
	*Config
}

func New(config *Config) *Service {
	return &Service{
		Config: config,
	}
}

func (s *Service) GetRequest(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != "GET" {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}
		next.ServeHTTP(w, r)
	})
}

func (s *Service) PostRequest(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != "POST" {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}
		next.ServeHTTP(w, r)
	})
}

func (s *Service) RequireHeaders(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var errors []string
		var response models.HttpResponse

		reqHeaders := getRequestHeaders(r)

		if reqHeaders.APIKey == "" {
			errors = append(errors, "x-api-key header required")
		}

		if reqHeaders.ClientID == "" {
			errors = append(errors, "x-client-id header required")
		}

		if errors != nil {
			response.Message = strings.Join(errors, ", ")
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(response)
			s.Logger.WarnWithFields(response.Message,
				log.Fields{
					"x-client-id":        reqHeaders.ClientID,
					"x-forwarded-for":    reqHeaders.XForwardedFor,
					"request-authorized": false,
					"remote-addr":        reqHeaders.RemoteAddr,
					"url-path":           r.URL.Path,
				})
			return
		}

		next.ServeHTTP(w, r)
	})
}

func (s *Service) Auth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		reqHeaders := getRequestHeaders(r)

		err := s.ClientRepo.ClientExists(r.Context(), reqHeaders)
		if err != nil {
			s.Logger.WarnWithFields("authorization failed",
				log.Fields{
					"x-client-id":        reqHeaders.ClientID,
					"x-forwarded-for":    reqHeaders.XForwardedFor,
					"request-authorized": false,
					"remote-addr":        reqHeaders.RemoteAddr,
					"url-path":           r.URL.Path,
				})
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		s.Logger.InfoWithFields("authorization passed",
			log.Fields{
				"x-client-id":        reqHeaders.ClientID,
				"x-forwarded-for":    reqHeaders.XForwardedFor,
				"request-authorized": true,
				"remote-addr":        reqHeaders.RemoteAddr,
				"url-path":           r.URL.Path,
			})

		// Replace the API key value to prevent logging it accidently
		r.Header.Set("x-api-key", "0")
		next.ServeHTTP(w, r)
	})
}

func getRequestHeaders(r *http.Request) models.RequestHeaders {
	clientID := r.Header.Get("x-client-id")
	apiKey := r.Header.Get("x-api-key")
	xForwardedFor := r.Header.Get("x-forwarded-for")
	remoteAddr := r.RemoteAddr

	reqHeaders := models.RequestHeaders{
		APIKey:        apiKey,
		ClientID:      clientID,
		XForwardedFor: xForwardedFor,
		RemoteAddr:    remoteAddr,
	}

	return reqHeaders
}
