package main

import (
	"os"
	"os/signal"

	"github.com/joho/godotenv"
	"github.com/robpaul9/cloud-object-malware-scanner/adapters/aws"
	"github.com/robpaul9/cloud-object-malware-scanner/adapters/gcp"
	"github.com/robpaul9/cloud-object-malware-scanner/adapters/metadefender"
	"github.com/robpaul9/cloud-object-malware-scanner/adapters/redis"
	"github.com/robpaul9/cloud-object-malware-scanner/adapters/server"
	"github.com/robpaul9/cloud-object-malware-scanner/config"
	"github.com/robpaul9/cloud-object-malware-scanner/db"
	dbclient "github.com/robpaul9/cloud-object-malware-scanner/db/client"
	"github.com/robpaul9/cloud-object-malware-scanner/entities/pool"
	cloudstorage "github.com/robpaul9/cloud-object-malware-scanner/usecases/cloud-storage"
	malwarescanner "github.com/robpaul9/cloud-object-malware-scanner/usecases/malware-scanner"
	"github.com/robpaul9/cloud-object-malware-scanner/usecases/middleware"
	"github.com/robpaul9/cloud-object-malware-scanner/usecases/pubsub"
	"github.com/robpaul9/cloud-object-malware-scanner/usecases/scanner"
)

func main() {
	err := godotenv.Load()
	if err != nil {
		panic("no .env file found")
	}

	config := config.NewConfig()

	database, err := db.New(
		&db.Config{
			DatabaseName: config.DBName,
			Host:         config.DBHost,
			Password:     config.DBPassword,
			User:         config.DBUser,
			Port:         config.DBPort,
		})
	if err != nil {
		config.Logger.Panic(err)
	}
	defer database.Close()

	clientRepo := dbclient.New(database)

	middlewareService := middleware.New(&middleware.Config{
		Logger:     config.Logger,
		ClientRepo: clientRepo,
	})

	redisInterface := redis.New(&redis.Config{
		Logger:        config.Logger,
		RedisPort:     config.RedisPort,
		RedisHost:     config.RedisHost,
		RedisPassword: config.RedisPassword,
		RedisDatabase: config.RedisDatabase,
		PubSubTopic:   config.PubSubTopic,
	})

	pubsubService := pubsub.New(&pubsub.Config{
		Logger:         config.Logger,
		RedisInterface: redisInterface,
	})

	gcpInterface := gcp.New(&gcp.Config{
		Logger: config.Logger,
	})

	awsInterface := aws.New(&aws.Config{
		Logger: config.Logger,
		Region: config.AWSRegion,
	})

	cloudStorageService := cloudstorage.New(&cloudstorage.Config{
		Logger:       config.Logger,
		GCPInterface: gcpInterface,
		AWSInterface: awsInterface,
	})

	metadefender := metadefender.New(&metadefender.Config{
		Logger:                     config.Logger,
		MetadefenderAPIKey:         config.MetadefenderAPIKey,
		MetadefenderRequestTimeout: config.MetadefenderTimeout,
	})

	malwareScannerService := malwarescanner.New(&malwarescanner.Config{
		Logger:                config.Logger,
		MetadefenderInterface: metadefender,
	})

	scannerService := scanner.New(&scanner.Config{
		Logger:                config.Logger,
		CloudStorageService:   cloudStorageService,
		MalwareScannerService: malwareScannerService,
	})

	dispatcher, quitChan := pool.NewDispatcher(
		config.MaxWorkers,
		config.MaxQueue,
		config.Logger,
	)

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)

	go dispatcher.Run()

	s := server.New(&server.Config{
		ServiceName:           config.ServiceName,
		ServicePort:           config.ServicePort,
		Logger:                config.Logger,
		PubSubTopic:           config.PubSubTopic,
		MiddlewareService:     *middlewareService,
		PubSubService:         *pubsubService,
		CloudStorageService:   *cloudStorageService,
		ScannerService:        *scannerService,
		Dispatcher:            *dispatcher,
		MalwareScannerService: *malwareScannerService,
	})

	go s.Start()

	select {
	case sig := <-c:
		config.Logger.Warnf("Got %s signal. Aborting...\n", sig)
		dispatcher.Stop()
		s.Stop()
		<-quitChan
	}
}
